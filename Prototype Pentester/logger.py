from time import sleep
import can
import signal
import csv
import time
import sys
import os
import json
from can.interfaces.vector import VectorBus
from can.interface import Bus

CONFIG_FILE = "test_config.json"

def load_config(path):
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[logger] Błąd wczytywania konfiguracji: {e}")
        sys.exit(1)

def test_channel(interface, channel, bitrate, label):
    try:
        if interface == "vector":
            VectorBus.get_application_config(app_name='python-can', app_channel=channel)
        test_bus = Bus(interface=interface, channel=channel, bitrate=bitrate)
        test_bus.shutdown()
        print(f"[logger] Kanał {channel} ({label}) jest dostępny.")
        return True
    except Exception as e:
        print(f"[logger] Brak dostępu do kanału {channel} ({label}): {e}")
        return False

print("[logger] Start logger.py")

config = load_config(CONFIG_FILE)
initial_channel = 1 - config.get("start_channel", 1)
bitrate1 = config.get("bitrate1", 500000)
bitrate2 = config.get("bitrate2", 500000)

if not test_channel("vector", initial_channel, bitrate1, "startowy"):
    sys.exit(1)

try:
    bus = can.interface.Bus(channel=initial_channel, interface='vector', bitrate=bitrate1)
except Exception as e:
    print(f"[logger] Błąd przy tworzeniu interfejsu CAN: {e}")
    sys.exit(1)

running = True
switched_file = False

csv_file = open('CAN1.csv', mode='w', newline='')
writer = csv.writer(csv_file)

def on_message_received(message):
    global running, bus, csv_file, writer, switched_file
    can_id = hex(message.arbitration_id)
    writer.writerow([can_id])

    if (not switched_file) and message.arbitration_id == 0x18F0010B and len(message.data) >= 8:
        if message.data[0:4] == [2, 1, 3, 7]:
            print("[logger] Warunki spełnione: CAN1.csv zapisane, stworzono CAN2.csv i switch kanałów między skryptami")
            time.sleep(10)
            csv_file.close()
            csv_file = open('CAN2.csv', mode='w', newline='')
            writer = csv.writer(csv_file)
            switched_file = True
            if not test_channel("vector", 1 - initial_channel, bitrate2, "drugi (po przełączeniu)"):
                running = False
                return
            try:
                bus.shutdown()
                bus = can.interface.Bus(channel=1 - initial_channel, interface='vector', bitrate=bitrate2)
            except Exception as e:
                print(f"[logger] Błąd przy przełączeniu kanału: {e}")
                running = False

    if switched_file and message.arbitration_id == 0x18F0010B and len(message.data) >= 8:
        if message.data[0:4] == [8, 8, 8, 8]:
            print("[logger] Zamknięcie programu na żądanie.")
            bus.shutdown()
            sys.exit()

def signal_handler(sig, frame):
    global running
    running = False
    print("[logger] Zatrzymywanie programu...")
    bus.shutdown()

signal.signal(signal.SIGINT, signal_handler)

print("[logger] Rozpoczęto odczyt ramek CAN...")

try:
    while running:
        if os.path.exists('kill_signal.txt'):
            print("[logger] Otrzymano sygnał do zamknięcia programu.")
            running = False

        try:
            message = bus.recv(timeout=0.1)
            if message is not None:
                on_message_received(message)
        except (can.CanError, OSError) as e:
            print(f"[logger] Utracono połączenie z interfejsem: {e}")
            running = False
except Exception as e:
    print(f"[logger] Błąd: {e}")
finally:
    bus.shutdown()
    try:
        csv_file.close()
    except Exception:
        pass
    if os.path.exists('kill_signal.txt'):
        os.remove('kill_signal.txt')
    print("[logger] Program zakończony.")

import can
import csv
import os

bitrate = 500000
kill_signal_file = 'kill_signal.txt'

def log_can_data(interface, channel, log_file):
    with open(log_file, mode='w', newline='') as csvfile:
        fieldnames = ['Timestamp', 'ID', 'Data']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        print(f'Rozpoczynam logowanie na interfejsie {interface}, kanale {channel}...')
        # Konfiguracja magistrali CAN
        try:
            bus = can.interface.Bus(channel=channel, interface=interface, bitrate=bitrate)
        except Exception as e:
            print(f'Błąd podczas otwierania magistrali CAN: {e}')
            return False

        with bus:
            while True:
                # Sprawdzenie kill_signal przed odbiorem ramki
                if os.path.exists(kill_signal_file):
                    print('Wykryto plik kill_signal.txt. Kończę logowanie.')
                    return False

                message = bus.recv(timeout=1.0)  # pauza 1 s, żeby nie blokować bez końca
                if message is not None:
                    writer.writerow({
                        'Timestamp': message.timestamp,
                        'ID': hex(message.arbitration_id),
                        'Data': message.data.hex()
                    })
                    print(f'Odebrano: ID={hex(message.arbitration_id)}, Data={list(message.data)}')

                    # Sprawdzenie warunku zakończenia - dotyczy tylko pierwszego kanału Vector
                    if (interface == 'vector' and
                        message.arbitration_id == 0x18F0010B and
                        list(message.data) == [2, 1, 3, 7, 2, 1, 3, 7]):
                        print('Wykryto ramkę zatrzymującą logowanie na Vector. Kończę...')
                        return True

def main():
    # Logowanie na Vector channel=1
    finished = log_can_data(interface='vector', channel=1, log_file='CAN1.csv')
    if not finished:
        print('Logowanie na Vector przerwane lub zakończone bez przełączenia.')
        return

    # Po wykryciu i zatrzymaniu na Vector, start logowania na Peak PCAN_USBBUS1
    finished = log_can_data(interface='pcan', channel='PCAN_USBBUS1', log_file='CAN2.csv')
    if not finished:
        print('Logowanie na Peak przerwane lub zakończone.')

    print('Skrypt zakończył działanie.')

if __name__ == '__main__':
    main()


from time import sleep
import can
import signal
import csv
import time
import sys  # Import sys for sys.exit()

# Vector settings
initial_channel = 1  # start channel
bitrate1 = 500000  # bitrate 500 kbps

# Initialize CAN bus on Vector interface
bus = can.interface.Bus(channel=initial_channel, interface='vector', bitrate=bitrate1)

# flag running
running = True

# flag on switching file/channel
switched_file = False

# Open CAN1.csv for writing
csv_file = open('CAN1.csv', mode='w', newline='')
writer = csv.writer(csv_file)

def on_message_received(message):
    global running
    global bus
    global csv_file
    global writer
    global switched_file

    can_id = hex(message.arbitration_id)
    #print(f"Odebrano wiadomość: ID = {can_id}, dane = {message.data}")  # Debug message showing ID and data

    # Write CAN ID to CSV
    writer.writerow([can_id])

    # Check conditions to switch files and bus
    if (not switched_file) and message.arbitration_id == 0x18F0010B and len(message.data) >= 8:
        if message.data[0] == 2 and message.data[1] == 1 and message.data[2] == 3 and message.data[3] == 7:
            print("Warunki spełnione: CAN1.csv zapisane, stworzono CAN2.csv i switch kanałów między skryptami")
            time.sleep(10)
            # Close CAN1.csv
            csv_file.close()

            # Open CAN2.csv for writing
            csv_file = open('CAN2.csv', mode='w', newline='')
            writer = csv.writer(csv_file)

            switched_file = True  # Mark that switching occurred

            # Shutdown current bus
            bus.shutdown()
            # Set new bus on PCAN interface
            bus = can.interface.Bus(interface='pcan', channel='PCAN_USBBUS1', bitrate=500000)

    # Check conditions to shutdown program
    if switched_file and message.arbitration_id == 0x18F0010B and len(message.data) >= 8:
        print(f"Sprawdzanie warunków zamknięcia: {message.data}")  # Debug message
        if message.data[0] == 8 and message.data[1] == 8 and message.data[2] == 8 and message.data[3] == 8:
            print("Zamknięcie programu na żądanie.")
            bus.shutdown()
            csv_file.close()
            sys.exit()  # Exit program

def signal_handler(sig, frame):
    global running
    running = False
    print("Zatrzymywanie programu...")
    try:
        bus.shutdown()
    except Exception as e:
        print(f"Błąd podczas zamykania magistrali: {e}")
    try:
        csv_file.close()
    except Exception as e:
        print(f"Błąd podczas zamykania pliku CSV: {e}")

signal.signal(signal.SIGINT, signal_handler)

print("Rozpoczęto odczyt ramek CAN...")

try:
    while running:
        message = bus.recv(timeout=0.1)
        if message is not None:
            on_message_received(message)
        #else:
            #print("Brak wiadomości do odebrania.")  # Informacja o braku wiadomości
except KeyboardInterrupt:
    print("Program przerwany przez użytkownika.")
except Exception as e:
    print(f"Błąd: {e}")
finally:
    try:
        csv_file.close()
    except Exception as e:
        print(f"Błąd przy zamykaniu pliku: {e}")
    try:
        bus.shutdown()
    except Exception as e:
        print(f"Błąd przy zamykaniu magistrali: {e}")
    print("Program zakończony.")


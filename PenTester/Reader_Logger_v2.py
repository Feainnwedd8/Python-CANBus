from time import sleep
import can
import signal
import csv
import time
import sys
import os
import pyttsx3
from playsound3 import playsound

# Vector settings
initial_channel = 0  # start channel
bitrate1 = 500000 # bitrate 250 kbps
bitrate2 = 250000  # in case of second channel in different bitrate
# CAN init
bus = can.interface.Bus(channel=initial_channel, interface='vector', bitrate=bitrate1, receive_own_messages=False)

# flag running
running = True

# flag on switching file/channel
switched_file = False

# CAN1.csv open and write
csv_file = open(r'D:\Users\sobkowiak_k\PycharmProjects\Python-CANBus\PenTester\CAN1.csv', mode='w', newline='')
writer = csv.writer(csv_file)  # Use csv.writer for easier writing

def on_message_received(message):
    global running
    global bus
    global csv_file
    global writer
    global switched_file

    can_id = hex(message.arbitration_id)
    print(can_id)
    # csv ID writing
    writer.writerow([can_id])

    # checking on switch demand
    if (not switched_file) and message.arbitration_id == 0x18FFA0E5 and len(message.data) >= 8:
        if message.data[0] == 2 and message.data[1] == 1 and message.data[2] == 3 and message.data[3] == 7:
            print("Warunki spełnione: CAN1.csv zapisane, stworzono CAN2.csv i switch kanałów między skryptami")
            time.sleep(10)
            # save and close CAN1.csv
            csv_file.close()

            # open writer on CAN2.csv
            csv_file = open(r'D:\Users\sobkowiak_k\PycharmProjects\Python-CANBus\PenTester\CAN2.csv', mode='w', newline='')
            writer = csv.writer(csv_file)

            switched_file = True  # setting the switching flag

            # close current bus
            bus.shutdown()
            # set new bus with second channel
            bus = can.interface.Bus(channel=0, interface='vector', bitrate=bitrate1)
            #bus = can.interface.Bus(interface='pcan', channel='PCAN_USBBUS1', bitrate=500000)

        if (switched_file) and message.arbitration_id == 0x18FFA0E5 and len(message.data) >= 8:
            if message.data[0] == 8 and message.data[1] == 8 and message.data[2] == 8 and message.data[3] == 8:
                print("Zamknięcie programu na żądanie.")
                bus.shutdown()
                sys.exit()

def signal_handler(sig, frame):
    global running
    running = False
    print("Zatrzymywanie programu...")
    bus.shutdown()

signal.signal(signal.SIGINT, signal_handler)

print("Rozpoczęto odczyt ramek CAN...")

try:
    while running:
        # Sprawdzenie pliku zabijającego
        if os.path.exists('kill_signal.txt'):
            print("Otrzymano sygnał do zamknięcia programu.")
            running = False

        # Sprawdzenie pliku przełączeniowego
        if not switched_file and os.path.exists('switch_signal.txt'):
            print("Otrzymano sygnał do przełączenia kanału. Przełączanie...")

            csv_file.close()

            # Nowy plik CSV
            csv_file = open(r'D:\Users\sobkowiak_k\PycharmProjects\Python-CANBus\PenTester\CAN2.csv', mode='w', newline='')
            writer = csv.writer(csv_file)

            # Przełączenie kanału
            bus.shutdown()
            bus = can.interface.Bus(channel=1, interface='vector', bitrate=bitrate1)

            switched_file = True
            os.remove('switch_signal.txt')

        message = bus.recv(timeout=0.1)
        if message is not None:
            on_message_received(message)

except Exception as e:
    print(f"Błąd: {e}")
finally:
    bus.shutdown()
    # close and save CAN2.csv
    try:
        csv_file.close()
    except Exception:
        pass
    # Remove the kill signal file if it exists
    if os.path.exists('kill_signal.txt'):
        os.remove('kill_signal.txt')
    print("Program zakończony.")
#tes